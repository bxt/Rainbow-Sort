// Generated by CoffeeScript 1.9.1
(function() {
  var bsort, canvas, checkDone, checkDoneInterval, colours, context, defer, height, hsort, index, initColours, isort, qsort, rectHeight, rectWidth, ref, reset, sort, ssort, start, swapRects, timeouts, toHslString, width;

  ref = [20, 20], rectWidth = ref[0], rectHeight = ref[1];

  checkDoneInterval = null;

  colours = null;

  context = null;

  height = null;

  index = null;

  start = null;

  width = null;

  canvas = null;

  timeouts = [];

  defer = function(fn) {
    return timeouts.push(window.setTimeout(fn, 0));
  };

  toHslString = function(h) {
    return "hsl(" + h + ", 100%, 50%)";
  };

  initColours = function() {
    var hue, k, ref1, ref2, results, val, x, y;
    results = [];
    for (x = k = 0, ref1 = width, ref2 = rectWidth; ref2 > 0 ? k < ref1 : k > ref1; x = k += ref2) {
      results.push((function() {
        var l, ref3, ref4, results1;
        results1 = [];
        for (y = l = 0, ref3 = height, ref4 = rectHeight; ref4 > 0 ? l < ref3 : l > ref3; y = l += ref4) {
          val = Math.random();
          hue = Math.floor(256 * val);
          colours.push({
            val: val,
            hue: hue,
            x: x,
            y: y
          });
          context.fillStyle = toHslString(hue);
          results1.push(context.fillRect(x, y, rectWidth, rectHeight));
        }
        return results1;
      })());
    }
    return results;
  };

  checkDone = function() {
    var end, i, k, ms, ref1;
    for (i = k = 1, ref1 = colours.length; 1 <= ref1 ? k < ref1 : k > ref1; i = 1 <= ref1 ? ++k : --k) {
      if (colours[i - 1].val > colours[i].val) {
        return;
      }
    }
    end = Date.now();
    window.clearInterval(checkDoneInterval);
    ms = end - start;
    $('#algoName').html($('#algo').val());
    return $('#ms').html(ms);
  };

  reset = function() {
    var ref1, timeout, win;
    if (checkDoneInterval != null) {
      window.clearInterval(checkDoneInterval);
    }
    while ((timeout = timeouts.pop())) {
      window.clearTimeout(timeout);
    }
    colours = [];
    index = 1;
    win = $(document);
    ref1 = [$(document).width(), $(document).height()], width = ref1[0], height = ref1[1];
    canvas.attr('width', width);
    canvas.attr('height', height);
    context = canvas[0].getContext('2d');
    start = Date.now();
    initColours();
    defer(sort);
    return checkDoneInterval = window.setInterval(checkDone, 10);
  };

  swapRects = function(ind1, ind2) {
    var swap, val1, val2;
    val1 = colours[ind1];
    val2 = colours[ind2];
    swap = function(field) {
      var tmp;
      tmp = val1[field];
      val1[field] = val2[field];
      return val2[field] = tmp;
    };
    swap('val');
    swap('hue');
    context.fillStyle = toHslString(val1.hue);
    context.fillRect(val1.x, val1.y, rectWidth, rectHeight);
    context.fillStyle = toHslString(val2.hue);
    return context.fillRect(val2.x, val2.y, rectWidth, rectHeight);
  };

  isort = function() {
    var j, k, ref1;
    for (j = k = ref1 = index; ref1 <= 0 ? k < 0 : k > 0; j = ref1 <= 0 ? ++k : --k) {
      if (colours[j - 1].val > colours[j].val) {
        swapRects(j - 1, j);
      }
    }
    index++;
    if (index < colours.length) {
      return defer(isort);
    }
  };

  ssort = function() {
    var j, k, min, ref1, ref2;
    min = index - 1;
    for (j = k = ref1 = index, ref2 = colours.length; ref1 <= ref2 ? k < ref2 : k > ref2; j = ref1 <= ref2 ? ++k : --k) {
      if (colours[j].val < colours[min].val) {
        min = j;
      }
    }
    swapRects(index - 1, min);
    index++;
    if (index < colours.length) {
      return defer(ssort);
    }
  };

  bsort = function() {
    var i, k, ref1, swapped;
    swapped = false;
    for (i = k = 1, ref1 = colours.length; 1 <= ref1 ? k < ref1 : k > ref1; i = 1 <= ref1 ? ++k : --k) {
      if (colours[i - 1].val > colours[i].val) {
        swapRects(i - 1, i);
        swapped = true;
      }
    }
    if (swapped) {
      return defer(bsort);
    }
  };

  qsort = function(tukey) {
    var doQsort, getPivotInd, medianOfThree, partition;
    medianOfThree = function(a, b, c) {
      var m0, m1, m2;
      m0 = b;
      m1 = a;
      m2 = c;
      if (colours[m1].val < colours[m0].val) {
        swapRects(m1, m0);
      }
      if (colours[m2].val < colours[m1].val) {
        swapRects(m2, m1);
      }
      if (colours[m1].val < colours[m0].val) {
        return swapRects(m1, m0);
      }
    };
    getPivotInd = function(from, to) {
      var mid, s;
      mid = Math.floor(from + (to - from) / 2);
      if (!tukey) {
        return mid;
      }
      if (to - from > 40) {
        s = Math.floor((to - from) / 8);
        medianOfThree(from, from + s, from + 2 * s);
        medianOfThree(mid, mid - s, mid + s);
        medianOfThree(to - 1, to - 1 - s, to - 1 - 2 * s);
      }
      medianOfThree(from, mid, to - 1);
      return from;
    };
    partition = function(from, to, pivotInd) {
      var i, k, pivot, ref1, ref2;
      pivot = colours[pivotInd].val;
      swapRects(pivotInd, to);
      pivotInd = from;
      for (i = k = ref1 = from, ref2 = to; ref1 <= ref2 ? k < ref2 : k > ref2; i = ref1 <= ref2 ? ++k : --k) {
        if (colours[i].val <= pivot) {
          swapRects(i, pivotInd);
          pivotInd++;
        }
      }
      swapRects(pivotInd, to);
      return pivotInd;
    };
    doQsort = function(from, to) {
      var pivotInd;
      if (from >= to) {
        return;
      }
      pivotInd = getPivotInd(from, to);
      pivotInd = partition(from, to, pivotInd);
      return defer(function() {
        doQsort(from, pivotInd - 1);
        return doQsort(pivotInd + 1, to);
      });
    };
    return doQsort(0, colours.length - 1);
  };

  hsort = function() {
    var fn1, i, k, l, maxHeapify, popMaxValue, ref1, ref2, size, stack, work;
    stack = [];
    work = function() {
      if (stack.length) {
        stack.pop()();
        return defer(work);
      }
    };
    size = colours.length;
    maxHeapify = function(i) {
      var largest, left, right;
      left = i * 2 + 1;
      right = i * 2 + 2;
      largest = i;
      if (left < size && colours[left].val > colours[i].val) {
        largest = left;
      }
      if (right < size && colours[right].val > colours[largest].val) {
        largest = right;
      }
      if (i !== largest) {
        swapRects(i, largest);
        return maxHeapify(largest);
      }
    };
    popMaxValue = function() {
      size--;
      swapRects(0, size);
      if (size > 0) {
        return maxHeapify(0);
      }
    };
    for (i = k = ref1 = size - 1; ref1 <= 0 ? k < 0 : k > 0; i = ref1 <= 0 ? ++k : --k) {
      stack.push(popMaxValue);
    }
    fn1 = function(i) {
      return stack.push(function() {
        return maxHeapify(i);
      });
    };
    for (i = l = 0, ref2 = Math.floor(size / 2) - 1; 0 <= ref2 ? l <= ref2 : l >= ref2; i = 0 <= ref2 ? ++l : --l) {
      fn1(i);
    }
    return work();
  };

  sort = bsort;

  $(document).ready(function() {
    canvas = $('#mainCanvas');
    $('#squareSize').val(rectWidth);
    window.onresize = function() {
      return reset();
    };
    $('#algo').change(function() {
      var selected;
      selected = $('#algo').val();
      sort = (function() {
        switch ($(this).children(':selected').attr('id')) {
          case 'bsort':
            return bsort;
          case 'isort':
            return isort;
          case 'qsort1':
            return function() {
              return qsort(false);
            };
          case 'qsort2':
            return function() {
              return qsort(true);
            };
          case 'hsort':
            return hsort;
          case 'ssort':
            return ssort;
        }
      }).call(this);
      return reset();
    });
    $('#squareSize').change(function() {
      var n;
      n = parseInt($('#squareSize').val(), 10);
      if (isNaN(n)) {
        return;
      }
      rectWidth = rectHeight = n;
      return reset();
    });
    $('#reset').click(function() {
      return reset();
    });
    return reset();
  });

}).call(this);
